// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jzon from "rescript-jzon/src/Jzon.mjs";
import * as Uuid from "uuid";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Store from "./Store.mjs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";

function helloWorld(param) {
  var result = {};
  result["Hello"] = "World";
  return result;
}

function jsonResult(o) {
  return Belt_Option.mapWithDefault(o, {
              TAG: /* Error */1,
              _0: {
                NAME: "SyntaxError",
                VAL: "Invalid JSON"
              }
            }, (function (s) {
                return {
                        TAG: /* Ok */0,
                        _0: s
                      };
              }));
}

var errorResultCodec = Jzon.object1((function (param) {
        return param.error;
      }), (function (error) {
        return {
                TAG: /* Ok */0,
                _0: {
                  error: error
                }
              };
      }), Jzon.field("error", Jzon.string));

var genericSuccessCodec = Jzon.object1((function (param) {
        return param.success;
      }), (function (success) {
        return {
                TAG: /* Ok */0,
                _0: {
                  success: success
                }
              };
      }), Jzon.field("success", Jzon.bool));

var genericIdCodec = Jzon.object1((function (param) {
        return param.id;
      }), (function (id) {
        return {
                TAG: /* Ok */0,
                _0: {
                  id: id
                }
              };
      }), Jzon.field("id", Jzon.string));

var addRecipeInputCodec = Jzon.object3((function (param) {
        return [
                param.title,
                param.ingredients,
                param.instructions
              ];
      }), (function (param) {
        return {
                TAG: /* Ok */0,
                _0: {
                  title: param[0],
                  ingredients: param[1],
                  instructions: param[2]
                }
              };
      }), Jzon.field("title", Jzon.string), Jzon.field("ingredients", Jzon.string), Jzon.field("instructions", Jzon.string));

var addTagToRecipeInputCodec = Jzon.object2((function (param) {
        return [
                param.recipeId,
                param.tag
              ];
      }), (function (param) {
        return {
                TAG: /* Ok */0,
                _0: {
                  recipeId: param[0],
                  tag: param[1]
                }
              };
      }), Jzon.field("recipeId", Jzon.string), Jzon.field("tag", Jzon.string));

var recipeCodec = Jzon.object7((function (param) {
        return [
                param.id,
                param.title,
                param.ingredients,
                param.instructions,
                param.tags,
                param.updatedAt,
                param.deleted
              ];
      }), (function (param) {
        return {
                TAG: /* Ok */0,
                _0: {
                  id: param[0],
                  title: param[1],
                  ingredients: param[2],
                  instructions: param[3],
                  tags: param[4],
                  updatedAt: param[5],
                  deleted: param[6]
                }
              };
      }), Jzon.field("id", Jzon.string), Jzon.field("title", Jzon.string), Jzon.field("ingredients", Jzon.string), Jzon.field("instructions", Jzon.string), Jzon.field("tags", Jzon.array(Jzon.string)), Jzon.field("updatedAt", Jzon.$$float), Jzon.field("deleted", Jzon.bool));

function addRecipe(bodyOption) {
  var jsonBodyOption = Belt_Result.flatMap(jsonResult(bodyOption), (function (j) {
          return Curry._1(Jzon.decode(addRecipeInputCodec), j);
        }));
  if (jsonBodyOption.TAG !== /* Ok */0) {
    return Curry._1(Jzon.encode(errorResultCodec), {
                error: Jzon.DecodingError.toString(jsonBodyOption._0)
              });
  }
  var match = jsonBodyOption._0;
  var id = Uuid.v4();
  Store.Reducer.dispatch({
        TAG: /* AddRecipe */0,
        id: id,
        title: match.title,
        ingredients: match.ingredients,
        instructions: match.instructions
      });
  return Curry._1(Jzon.encode(genericIdCodec), {
              id: id
            });
}

function addTagToRecipe(bodyOption) {
  var jsonBodyOption = Belt_Result.flatMap(jsonResult(bodyOption), (function (j) {
          return Curry._1(Jzon.decode(addTagToRecipeInputCodec), j);
        }));
  if (jsonBodyOption.TAG !== /* Ok */0) {
    return Curry._1(Jzon.encode(errorResultCodec), {
                error: Jzon.DecodingError.toString(jsonBodyOption._0)
              });
  }
  var match = jsonBodyOption._0;
  var recipe = Belt_MapString.get(Store.Reducer.getState(undefined).recipes, match.recipeId);
  if (recipe !== undefined) {
    Store.Reducer.dispatch({
          TAG: /* AddTag */1,
          recipeId: recipe.id,
          tag: match.tag
        });
    return Curry._1(Jzon.encode(genericSuccessCodec), {
                success: true
              });
  } else {
    return Curry._1(Jzon.encode(errorResultCodec), {
                error: "recipe does not exist"
              });
  }
}

function getRecipe(params) {
  var state = Store.Reducer.getState(undefined);
  var recipeResult = Curry._1(Jzon.decode(genericIdCodec), params);
  if (recipeResult.TAG !== /* Ok */0) {
    return Curry._1(Jzon.encode(errorResultCodec), {
                error: Jzon.DecodingError.toString(recipeResult._0)
              });
  }
  var recipe = Belt_MapString.get(state.recipes, recipeResult._0.id);
  if (recipe !== undefined) {
    return Curry._1(Jzon.encode(recipeCodec), recipe);
  } else {
    return Curry._1(Jzon.encode(errorResultCodec), {
                error: "unable to find that recipe"
              });
  }
}

function getTag(params) {
  var jsonResponse = {};
  var state = Store.Reducer.getState(undefined);
  var taggedRecipesOption = Belt_Option.flatMap(Belt_Option.flatMap(Js_dict.get(params, "tag"), Js_json.decodeString), (function (tag) {
          return Belt_MapString.get(state.tags, tag);
        }));
  if (taggedRecipesOption !== undefined) {
    var recipes = Belt_Array.map(Belt_Array.keep(Belt_Array.map(taggedRecipesOption.recipes, (function (id) {
                    return Belt_Option.map(Belt_MapString.get(state.recipes, id), (function (recipe) {
                                  var dict = {};
                                  dict["id"] = id;
                                  dict["title"] = recipe.title;
                                  return dict;
                                }));
                  })), Belt_Option.isSome), (function (opt) {
            return opt;
          }));
    jsonResponse["recipes"] = recipes;
  } else {
    jsonResponse["error"] = "tag not found";
  }
  return jsonResponse;
}

export {
  helloWorld ,
  jsonResult ,
  errorResultCodec ,
  genericSuccessCodec ,
  genericIdCodec ,
  addRecipeInputCodec ,
  addTagToRecipeInputCodec ,
  recipeCodec ,
  addRecipe ,
  addTagToRecipe ,
  getRecipe ,
  getTag ,
  
}
/* errorResultCodec Not a pure module */
